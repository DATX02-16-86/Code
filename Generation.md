#World generation

This is a proposal on how to structure the world generation pipeline in a way that is as flexible as possible, yet easy to understand and use.

The world generation is separated into a pipeline with several stages, each of which performs a single task but has access to the data generated by previous stages. This separation makes the whole generation easy to reason over, while also giving more flexibility in defining the end result. 

Each pipeline stage can be configured by adding one or more modules specific to that stage, where each module performs some smaller part of generation. The way modules are connected depends on that stage. In most cases these modules should try to perform one smaller task only, but there will of course be scenarios where large monolithic modules are required to get the desired result. Each module may have configurable properties of its own, but this is completely module-specific.

The end result generated by the pipeline depends on the configuration of the terrain stage, and therefore there is no predefined output format. However, there will be a limited number of terrain output types, which allows us to pre-create rendering, editing and storage functionality compatible with each type.

##Main pipeline stages:
 - Landmass generation
 - Height generation
 - Climate generation
 - Terrain generation
 - Feature generation
 - Structure generation

##Landmass generation

This stage defines the locations of landmasses within an ocean of some default type. Landmasses could be islands, whole continents or even a single gigantic area stretching the whole world.
The stage can also output auxiliary data for use by later stages, such as tectonic plates for more realistic simulation.
The reasoning for having this stage instead of integrating it in the height generation (which could have been done as well):
 - Defining the landmasses separately makes it easier to create modules that make interesting landscapes by allowing the module to only reason about shape instead of the whole landscape look.
 - Separating landmasses allows for more control over the end result, for example by using artist-created data as base input. This facilitates using our system for more than just completely random worlds.

The output of this stage consists of a bitmap where each bit indicates if there is land in that area.
Any auxiliary data is output through one or more additional id's for each segment, such as plate index. 

##Height generation

This stage defines the general height of each area chunk generated by the landmass stage. It does this for both landmass and non-landmass areas:
 - For non-landmass it could generate ocean depths depending on distance from landmass, with other factors such as tectonic plates, oceanic trenches, etc.
 - For landmass ot could generate the locations of highlands, moutain chains and lower areas.

The result of this stage depends completely on the stage configuration and modules used. One could use it for building an earth-like structure, simulating the formation of mountains and vulcanos. One could also configure it in a completely different way to generate a different planet.
The stage output is a map of low-frequency height indices used to feed later stages, as well as a bitmap of special area types for improved accuracy of later stages. Special area types could include volcanos, mountains or other custom data.

##Climate generation
This stage uses the data from landmass and height generation to define the climate of each area. By using the auxiliary data from both stages it should be possible to perform a fairly accurate simulation if wanted, while also allowing for a simple implementation that just looks at land height and proximity to ocean.
Examples of generated climates could be tundra, plains, desert, mountain or any earth-like climate. They could also be completely different climates defined by the user.
In most cases one would want a gradual transition between related climates instead of desert being next to a polar climate - this should be handled by this stage if needed.
The stage output is a map of climate types, represented as indices.

##Terrain generation
This stage is responsible for actually generating the inital land, using all previous stages as input. The way this land is generated depends on user requirements:
 - When used as initial terrain generation for a traditional type of game, this could simply generate a detailed heightmap and specific terrain types for an area.
 - When used for generating the whole world of a voxel-style game, this would generate a 3D-map of voxel types as input to later stages.

The stages after this are optional and only used for specific scenarios. The implementations are specific for certain pipeline configurations, such as whether using voxels or normal geometry. These stages work by modifying or adding to the existing generated terrain and therefore have no output of their own.

##Feature generation
This stage is responsible for generating specific land features that modify the terrain and cannot be represented by the previous stages. Examples of generatable features include:
 - Rivers
 - Lakes
 - Forests
 - Plants, grass
 - Caves
 - Resources that can be gathered by the player.

Basically, anything specific that belongs to the base terrain but cannot be represented in the general terms of previous stages is inserted here.

###Large-scale features
Some features, such as large rivers, would span many chunks of detailed terrain and require large-scale as well as detailed cohesion. This is impractical to do completely in this stage, as it would require holding large amounts of voxel data in memory. To solve this problem we can use the auxiliary data from earlier stages:
 - We define a river module for use in the height stage. This module is run after the others and uses the created height data to find suitable locations for large rivers.
 - The module outputs a bitmap, indicating for each segment if there will be a river in that area.
 - Later in the feature stage we have another river module that when generating a chunk checks if there is a river in the current chunks and its neighbors. It uses this to find out from what chunk edges a river will flow, and modifies the terrain accordingly.
 - This is done in each chunk. Since the river generation itself is deterministic and position-based, the edges of the river in each chunk will line up correctly without requiring inter-chunk passes.

##Structure generation
This final stage is used to generate specific, mostly non-organic structures that are not a natural part of the terrain (but may require modifications to it).
One could say that this stage adds the stuff that is the most specific for a game and used by gameplay, which is why it is only needed for specific use cases.
The stage can be very simple but also become very large and consist of multiple sub-stages, depending on the configuration.

The following is an example of a simple structure stage:
 - Use randomness and data from previous stages to find possible object locations.
 - Insert the objects at the found locations, possibly flattening the terrain locally to make it fit.
 - Examples of objects include watch towers, dungeons, small houses, etc.

The following is an example of a complex structure stage:
 - Use randomness and data from previous stages to find suitable locations for large cities.
 - Prepare each location by performing large modifications to the terrain, such as removing forest, flattening the terrain into plateaus, altering the flow of rivers, etc.
 - Procedurally generate a structure of roads, large buildings and basic city structure using L-systems and existing terrain structure to make it interesting.
 - Perform a pass of removing anomalies created by the previous changes, such as smoothing terrain, re-adding grass and sand layers, re-adding plants. This can be done using functionality from previous stages.
 - Perform these stages several more times for different structure types, such as highways between cities, smaller villages, dams, railroad networks, ...

This last stage can become extremely complex to implement concrete modules for. Therefore, we will most likely only create the basic framework needed to make the complex example possibly, with only simple modules from the basic example provided by us.

#Implementation
By separating each stage this way, the actual implementation of the basic framework becomes fairly simple. 
Even with the hard separation between stages, they can still pass enough information between each other to make basically any kind of generation possible; this is just a matter of configuration each stage with modules, some of which we can provide as examples (depending on time).

There will be an example implementation of the basic framework in this repo which can be expanded on, but most work will go to creating configurable modules for each stage that make the framework actually produce a result.
